{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1586506645074},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1586506645074},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1586506645074},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1586506645074},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1586506645074},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1586506645074},{"_id":"source/_posts/HOME.md","hash":"fa139d29e86fc0c638ab14fdb71d089eb9a36ede","modified":1586530321922},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1586506645074},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1586506645074},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1586506645074},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1586506645074},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1586506645074},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1586506645074},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1586506645074},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1586506645074},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1586506645074},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1586506645074},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1586506645074},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1586506645074},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1586506645074},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1586506645074},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1586506645074},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1586506645074},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1586506645074},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586506645074},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1586506645074},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1586506645074},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1586506645074},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1586506645074},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1586506645074},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1586506645074},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1586506645074},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1586506645074},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1586506645074},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1586506645074},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1586506645078},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1586506645078},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1586506645078},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1586506645074},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1586506645074},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1586506645074},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1586506645074},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1586506645074},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1586506645074},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1586506645074},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1586506645074},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1586506645074},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1586506645074},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1586506645074},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1586506645074},{"_id":"public/2020/04/10/HOME/index.html","hash":"47744bd8f8e14ace37495ad145091d7a0c6e0df6","modified":1586511303740},{"_id":"public/2020/04/10/hello-world/index.html","hash":"caf37745b8b8a5fe48f993902ce8ff16f6df03dc","modified":1586506999574},{"_id":"public/archives/index.html","hash":"c3b1f256bb3d9be29bf6fd10025259529d18ea3e","modified":1586530370504},{"_id":"public/archives/2020/index.html","hash":"e41fcf33fa79b137afe69aacbdf2dca4b92df18d","modified":1586530370504},{"_id":"public/archives/2020/04/index.html","hash":"d25e30755ea893b58e8c7fd471b82f2474f1f403","modified":1586530370504},{"_id":"public/index.html","hash":"7dfe94d6d0ab9ace2a09e6614ea370a5f58873e6","modified":1586530370504},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1586506999574},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1586506999574},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1586506999574},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1586506999574},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1586506999574},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1586506999574},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1586506999574},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1586506999574},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1586506999574},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1586506999574},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1586506999574},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1586506999574},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1586506999574},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1586506999574},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1586506999574},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1586506999574},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1586506999574},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1586506999574},{"_id":"public/css/style.css","hash":"d4cfa90089c78a8b791252afae9fafa3b5658900","modified":1586509201895},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1586506999574},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1586506999574},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1586506999574},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1586506999574},{"_id":"themes/aircloud/.gitignore","hash":"5a4a925cfd624633dafaacaced416c8d7272dcef","modified":1586508670384},{"_id":"themes/aircloud/LICENSE","hash":"218b4bf797149a2751a015812a9adefe368185c1","modified":1586508670384},{"_id":"themes/aircloud/_config.yml","hash":"0ad3a6ab2c9bb07fb1e030052622fdcde5c6f28a","modified":1586511301401},{"_id":"themes/aircloud/readme-en.md","hash":"2903b1e9db12cd72ed6f8c10be14cd7f6afd82cf","modified":1586508670388},{"_id":"themes/aircloud/readme.md","hash":"4be1fc64bd1dc335a986a39594564e89bd7eba43","modified":1586508670388},{"_id":"themes/aircloud/layout/catagory.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/layout/page.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/languages/en.yml","hash":"f3dd50ca369974ac7d335fb1cfabf4ebb04a64fa","modified":1586508670384},{"_id":"themes/aircloud/languages/zh.yml","hash":"9ffaff1f5d240c94e44f9ef3b02bbae146af0dd4","modified":1586508670384},{"_id":"themes/aircloud/layout/404.ejs","hash":"8a30233a7b99831bd771121b5f450aaba412e8d5","modified":1586508670388},{"_id":"themes/aircloud/layout/about.ejs","hash":"cec034166ce08d2f8c961178e07b2f0ceac95cf2","modified":1586508670388},{"_id":"themes/aircloud/layout/archive.ejs","hash":"0f8a062f4f2f0648b23bd8c4a21945a6ca60dc1f","modified":1586508670388},{"_id":"themes/aircloud/layout/index.ejs","hash":"09e2407d615be7fe7ac41d11df3b7026e7393080","modified":1586508670388},{"_id":"themes/aircloud/layout/layout.ejs","hash":"7efd113aee90e698e187d0ea1f0b42a1c00d210e","modified":1586508670388},{"_id":"themes/aircloud/layout/post.ejs","hash":"2eb5fc0c2bb801528c3db3b09e6cb4d073e3ad99","modified":1586508670388},{"_id":"themes/aircloud/layout/tags.ejs","hash":"1a174d9213d25d9bf6ef28aabdaea6661cdd88c8","modified":1586508670388},{"_id":"themes/aircloud/source/_less/about.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/diff.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/diff.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/page.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/page.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670388},{"_id":"themes/aircloud/source/_less/theme.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670392},{"_id":"themes/aircloud/source/_less/theme.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586508670392},{"_id":"themes/aircloud/layout/_partial/donate.ejs","hash":"81c976a3b7fa5c47ef61181d537220eaf1d55eac","modified":1586508670388},{"_id":"themes/aircloud/layout/_partial/footer.ejs","hash":"33db88f1b03548c5181c04d44387dc68a9c4cdf6","modified":1586508670388},{"_id":"themes/aircloud/layout/_partial/head.ejs","hash":"3f18d5d4951a205bab25b08d6bf85b054c84a21b","modified":1586508670388},{"_id":"themes/aircloud/layout/_partial/nav.ejs","hash":"079fa72aa7a02ee11f6a44a8a9e58eb80fe28190","modified":1586508670388},{"_id":"themes/aircloud/layout/_partial/toc.ejs","hash":"41d11d159011466f0b6272aca9a74df8642b693f","modified":1586508670388},{"_id":"themes/aircloud/source/_less/archive.css","hash":"905efcc06a62d1e8b60df0e12434afa353378d3a","modified":1586508670388},{"_id":"themes/aircloud/source/_less/archive.less","hash":"5538d38614960e69b97a7f80f38b5933851212b8","modified":1586508670388},{"_id":"themes/aircloud/source/_less/common.css","hash":"64914aa6ecd5b948676870e0809e0f220b162e3b","modified":1586508670388},{"_id":"themes/aircloud/source/_less/common.less","hash":"8aef4d8cfdefbcd2e28d4985a4f79a5005ca0b6c","modified":1586508670388},{"_id":"themes/aircloud/source/_less/donate.css","hash":"ae6a676a42321512f0536c5230bb53084aaf2c2f","modified":1586508670388},{"_id":"themes/aircloud/source/_less/donate.less","hash":"d63139f4aa148bf894afa5c1007a4398696a0e4c","modified":1586508670388},{"_id":"themes/aircloud/source/_less/gitment.css","hash":"7d560b64e367129f98424052c660ae82b03a1d02","modified":1586508670388},{"_id":"themes/aircloud/source/_less/gitment.less","hash":"916deb8ecdee798d7a9b43b544e31dfd5bbd6de4","modified":1586508670388},{"_id":"themes/aircloud/source/_less/hightlight.css","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1586508670388},{"_id":"themes/aircloud/source/_less/hightlight.less","hash":"4e5a9ec3e88fbc2ce0faabceff8d3f5099ea1012","modified":1586508670388},{"_id":"themes/aircloud/source/_less/index.css","hash":"52fe4d1b93dfb4c9c9d63e24862354b6a0ef47f8","modified":1586508670388},{"_id":"themes/aircloud/source/_less/index.less","hash":"502d689e3568056cc27dd4da7da2499b0be4253e","modified":1586508670388},{"_id":"themes/aircloud/source/_less/layout.css","hash":"40d7cadf42b130ea1b40de1ae73b2b00e27f476f","modified":1586508670388},{"_id":"themes/aircloud/source/_less/layout.less","hash":"194ac7db2eeee7307fcb7470302f8172100181fb","modified":1586508670388},{"_id":"themes/aircloud/source/_less/nav.css","hash":"32e352d71dc2e67d69a26d8b5116a27d8d2a7718","modified":1586508670388},{"_id":"themes/aircloud/source/_less/nav.less","hash":"627e33cafb4ca9c191053b10917fc21c68c6ee8c","modified":1586508670388},{"_id":"themes/aircloud/source/_less/post.css","hash":"4adf531589cb55413264c188b29ae47ab703beb8","modified":1586508670388},{"_id":"themes/aircloud/source/_less/post.less","hash":"bbbd81c03e7581950d82bf971eda49e8bed7bee1","modified":1586508670392},{"_id":"themes/aircloud/source/_less/tag.css","hash":"3250887aaae0bc62bd82082d000ce3de8cc55ab6","modified":1586508670392},{"_id":"themes/aircloud/source/_less/tag.less","hash":"47e1ce2f55e2b62beefd0f69dfe7deb594e7b309","modified":1586508670392},{"_id":"themes/aircloud/source/_less/toc.css","hash":"83b1a219e7fe66d9d6cc34600e5a16311381a883","modified":1586508670392},{"_id":"themes/aircloud/source/_less/toc.less","hash":"c873ce552b22b0aa2c51a386a91516cadf9160ba","modified":1586508670392},{"_id":"themes/aircloud/source/_less/variables.css","hash":"9768d38beea904c4febc704192a49c8f7ae6e06c","modified":1586508670392},{"_id":"themes/aircloud/source/_less/variables.less","hash":"49503f7a6c51edd6f1dbdea5345df6bb903b18a5","modified":1586508670392},{"_id":"themes/aircloud/source/css/aircloud.css","hash":"e6082557a5f0e546169ab1aa0ba29bda4ef5c182","modified":1586508670392},{"_id":"themes/aircloud/source/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1586508670392},{"_id":"themes/aircloud/source/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1586508670392},{"_id":"themes/aircloud/source/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1586508670392},{"_id":"themes/aircloud/source/js/index.js","hash":"1fed4485eedf5309e504aec35596955e5d692c7d","modified":1586508670392},{"_id":"themes/aircloud/source/_less/_partial/footer.css","hash":"e00d722211b4695449d72850340ac0dd701d6ede","modified":1586508670388},{"_id":"themes/aircloud/source/_less/_partial/footer.css.map","hash":"9e8d4df5d08425de5a8b247d0dd8b805c6edc661","modified":1586508670388},{"_id":"themes/aircloud/source/_less/_partial/footer.less","hash":"d1469f97daf750f3e4be18c4d640772780c32a75","modified":1586508670388},{"_id":"themes/aircloud/source/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1586508670392},{"_id":"public/css/aircloud.css.map","hash":"50db34961d11f6f461e23912609d25141068a6fc","modified":1586509201895},{"_id":"public/css/aircloud.less","hash":"45cab2da310dbfcba37ac3db657db77b4adac60d","modified":1586509201895},{"_id":"public/js/index.js","hash":"1fed4485eedf5309e504aec35596955e5d692c7d","modified":1586509201895},{"_id":"public/css/aircloud.css","hash":"e6082557a5f0e546169ab1aa0ba29bda4ef5c182","modified":1586509201895},{"_id":"public/css/gitment.css","hash":"926b553be983d6dd90bcb60c5d6d4ee215d268a6","modified":1586509201895},{"_id":"public/js/gitment.js","hash":"89687f8fffe1125e08323fd6635ca4e53771c05e","modified":1586509201895},{"_id":"source/img/favicon.ico","hash":"714e252062bd7660b43c5af447290baba3d470b7","modified":1586510692599},{"_id":"public/search.xml","hash":"059c0a44e26d2e70de91a125f5dfcfaa29481144","modified":1586511236548},{"_id":"public/img/favicon.ico","hash":"714e252062bd7660b43c5af447290baba3d470b7","modified":1586511236548},{"_id":"public/search.json","hash":"3334a7fd0680d560362f8cb20cad69777b3afaa0","modified":1586511534102},{"_id":"source/_posts/Hexo搭建个人博客.md","hash":"c1c88d6a7eefe5b7a13e8e8e5f1135c7de29fc30","modified":1586530358579},{"_id":"public/2020/04/10/Hexo搭建个人博客/index.html","hash":"1c2a485792f83d3389a1fe198a4d76a55d4889d5","modified":1586530370504},{"_id":"public/tags/Linux-Hexo/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586530195746},{"_id":"source/about/index.md","hash":"19059a87f621ab0c7720ae10565ec40f1a84ccb5","modified":1586511661907},{"_id":"source/img/avatar.jpg","hash":"714e252062bd7660b43c5af447290baba3d470b7","modified":1586511697173},{"_id":"source/tags/index.md","hash":"27e9551b06522360562dc6012cdcc04f9565e1f5","modified":1586530220056},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586530195746},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1586530195746},{"_id":"public/img/avatar.jpg","hash":"714e252062bd7660b43c5af447290baba3d470b7","modified":1586511801981},{"_id":"source/images/avatar.jpg","hash":"714e252062bd7660b43c5af447290baba3d470b7","modified":1586530309250},{"_id":"source/images/c++_erase/1.png","hash":"fd50d2d73c15f58c301c91746d426a3632bf7019","modified":1586530309250},{"_id":"source/images/c++_erase/2.png","hash":"fff82c6dd7e1a20d50ec5db0d34fe2baf9f55f21","modified":1586530309250},{"_id":"source/images/c++_split_getline/1.png","hash":"930614c38f07b163cd598da30b37c754e4670d8b","modified":1586530309250},{"_id":"source/_posts/bresenham.md","hash":"79dd7592a7e62a2869675cc64ade0c62376a2e73","modified":1586530358483},{"_id":"source/_posts/c++_erase.md","hash":"f9231a02bcd26c60d55c6227ba234876addfbc4b","modified":1586530358511},{"_id":"source/_posts/c-split-getline.md","hash":"d9aeb9fc74aee82c0f2ea8bd628e499241dfd41f","modified":1586530358543},{"_id":"source/_posts/九宫格输入法-字符串处理方法.md","hash":"5ff06dcee93e2e3217bb431a9f3ffd77be04d0d7","modified":1586530358611},{"_id":"source/_posts/反转字符串.md","hash":"b6e3e2343399d7f20277c3b0d9dc5f56e7027639","modified":1586530358643},{"_id":"public/2019/07/12/c-split-getline/index.html","hash":"f7e30b661a371558692740b75a6342c085da12c6","modified":1586530370504},{"_id":"public/2019/07/12/反转字符串/index.html","hash":"64f5a81a6801213642b4f1e1d9b85845d0dd3f6c","modified":1586530370504},{"_id":"public/2019/07/12/九宫格输入法-字符串处理方法/index.html","hash":"c3769254182700101a7b4cc0c021c8a21c968cb4","modified":1586530370504},{"_id":"public/2019/07/12/c++_erase/index.html","hash":"d225d1562b3994a6ff56c855c2a0256235acaf0c","modified":1586530370504},{"_id":"public/2018/09/17/bresenham/index.html","hash":"7ec3e00231d2b4d9d0a4b0efbfe23a83696d5705","modified":1586530370504},{"_id":"public/archives/2018/index.html","hash":"45b1216568ca1e9885b749239478f7f7c5c4c66d","modified":1586530370504},{"_id":"public/archives/2018/09/index.html","hash":"cb251ca731ca08a02dd76f9384e883df261880c3","modified":1586530370504},{"_id":"public/archives/2019/index.html","hash":"ed820b0de5ba6bd81b4dd6a8394bc75d4bcd85ec","modified":1586530370504},{"_id":"public/archives/2019/07/index.html","hash":"6058fb7f6e68b0158c716c324047e8d2d03710e9","modified":1586530370504},{"_id":"public/tags/Linux/index.html","hash":"5670f54da0df1663e2b1574dec91219d0ea5f3ab","modified":1586530370504},{"_id":"public/tags/Hexo/index.html","hash":"edb2afd9b5469a8c3c88215592bda971b480139d","modified":1586530370504},{"_id":"public/tags/c/index.html","hash":"20507ff6e848fb15af6c4a2e7b160dac88935eb0","modified":1586530370504},{"_id":"public/tags/Computer-Graphics/index.html","hash":"9ae6c73676fd41b0570d5d2b7aea84946436427a","modified":1586530370504},{"_id":"public/tags/string/index.html","hash":"69e3c3f4adbc8e1f3c8c9978adcdb73dc0492c56","modified":1586530370504},{"_id":"public/tags/compete/index.html","hash":"70eb2ecb194578384085f64a583679d32576ad9c","modified":1586530370504}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"bresenham算法","date":"2018-09-17T14:16:44.000Z","_content":"\n在实验课上用自己的算法画直线被 diss 效率低  \n花了半天时间看了下 Bresenham 算法真 🐮🍺  \n总结一下其中的精妙之处  \nBresebham 直线生成算法的基本原理是，每次在最大位移方向上走一步，而另一个方向是走步还是不走步取决于误差项的判别。  \n声明 k 为斜率  \n在 0≤k<1 的情况下，假设当前点是 P($x_1$,$y_1$)，则下一个点在 $P_u$($x_1$+1,$y_1$+1)与 $P_d$($x_1$+1,$y_1$)中选一。  \n以 M 表示 $P_u$ 与 $P_d$ 的中点，即 M($x_1$+1,$y_1$+0.5)。设 Q 是理想直线与 x=$x_i$+1 的交点；  \n显然，若 M 在 Q 的下方，则 Pu($x_1$+1,$y_1$+1)离直线较近，应取为下一个像素；否则应取 $P_d$($x_1$+1,$y_1$)。  \n理解并不难 主要在于实现  \n依据该算法的原理基本能够实现  \n窝先试着自己写了一会  \n如果要实现各个方向的二维直线绘制  \n需要考虑多种情况 写出来很不美观  \n教材上给出了更好的解决方案：  \n同样以 0≤k<1 为例  \n每次选取下个点时理想直线的 y 坐标都步进 k 个单位长度  \n累加值即为误差项 $d_i$  \n当 $d_i$ 大于 0.5 时选取 Pu 否则选取 $P_d$ 并使 $d_i$-1  \n令 $e_i$=$d_i$-0.5  \n则 $e_i$>0 时选取 Pu 否则选取 $P_d$  \n经过改进，算法的效率大幅提升  \n但其中在计算斜率与误差项时会用到小数和除法  \n并且下一步的选择只与误差项的符号有关  \n因此可以进一步改进：  \n可知 $e_i$ 的值由三种值组成：$e_i$=-1/2(初始值)+(n 个)y/x(步进值)-(m 个)1(调整值)...  \n同乘 2x 即得 2x*$e_i$=-x+(n 个)2*y-(m 个)2\\*x....  \n这样即可得到仅由整数构成的算法  \n以上仅为对 0≤k<1 情况下的讨论  \n其余的情况类似  \n附一段杂乱无章的代码\n\n```\npoint<Type> now_point = start;\n  point<Type> e_step, point_step;\n  e_step.x = abs(step.x);\n  e_step.y = abs(step.y);\n  glBegin(GL_POINTS);\n  if (step.x == 0 && step.y == 0) //No Step\n    return;\n  point_step.x = (step.x == 0) ? 1 : step.x / e_step.x;\n  point_step.y = (step.y == 0) ? 1 : step.y / e_step.y;\n  if (step.x == 0) {   // k is endless\n    do{\n      glVertex2i(now_point.x, now_point.y);\n      now_point.y += point_step.y;\n    } while (now_point.y != end.y);\n  }\n  else if (step.y == 0) {   //k is zero\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      now_point.x += point_step.x;\n    } while (now_point.x != end.x);\n  }\n  else if (abs(step.y / step.x) == 0) {   // |k| < 1\n    Type e = -e_step.x;\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      e += 2 * e_step.y;\n      now_point.x += point_step.x;\n      if (e > 0) {\n        now_point.y += point_step.y;\n        e -= 2 * e_step.x;\n      }\n    } while (now_point.x != end.x);\n  }\n  else {    // |k| >= 1\n    Type e = -e_step.y;\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      e += 2 * e_step.x;\n      now_point.y += point_step.y;\n      if (e > 0) {\n        now_point.x += point_step.x;\n        e -= 2 * e_step.y;\n      }\n    } while (now_point.y != end.y);\n  }\n  glEnd();\n  glFlush();\n\n```\n","source":"_posts/bresenham.md","raw":"---\ntitle: bresenham算法\ndate: 2018-09-17 22:16:44\ntags:\n  - c++\n  - Computer Graphics\n---\n\n在实验课上用自己的算法画直线被 diss 效率低  \n花了半天时间看了下 Bresenham 算法真 🐮🍺  \n总结一下其中的精妙之处  \nBresebham 直线生成算法的基本原理是，每次在最大位移方向上走一步，而另一个方向是走步还是不走步取决于误差项的判别。  \n声明 k 为斜率  \n在 0≤k<1 的情况下，假设当前点是 P($x_1$,$y_1$)，则下一个点在 $P_u$($x_1$+1,$y_1$+1)与 $P_d$($x_1$+1,$y_1$)中选一。  \n以 M 表示 $P_u$ 与 $P_d$ 的中点，即 M($x_1$+1,$y_1$+0.5)。设 Q 是理想直线与 x=$x_i$+1 的交点；  \n显然，若 M 在 Q 的下方，则 Pu($x_1$+1,$y_1$+1)离直线较近，应取为下一个像素；否则应取 $P_d$($x_1$+1,$y_1$)。  \n理解并不难 主要在于实现  \n依据该算法的原理基本能够实现  \n窝先试着自己写了一会  \n如果要实现各个方向的二维直线绘制  \n需要考虑多种情况 写出来很不美观  \n教材上给出了更好的解决方案：  \n同样以 0≤k<1 为例  \n每次选取下个点时理想直线的 y 坐标都步进 k 个单位长度  \n累加值即为误差项 $d_i$  \n当 $d_i$ 大于 0.5 时选取 Pu 否则选取 $P_d$ 并使 $d_i$-1  \n令 $e_i$=$d_i$-0.5  \n则 $e_i$>0 时选取 Pu 否则选取 $P_d$  \n经过改进，算法的效率大幅提升  \n但其中在计算斜率与误差项时会用到小数和除法  \n并且下一步的选择只与误差项的符号有关  \n因此可以进一步改进：  \n可知 $e_i$ 的值由三种值组成：$e_i$=-1/2(初始值)+(n 个)y/x(步进值)-(m 个)1(调整值)...  \n同乘 2x 即得 2x*$e_i$=-x+(n 个)2*y-(m 个)2\\*x....  \n这样即可得到仅由整数构成的算法  \n以上仅为对 0≤k<1 情况下的讨论  \n其余的情况类似  \n附一段杂乱无章的代码\n\n```\npoint<Type> now_point = start;\n  point<Type> e_step, point_step;\n  e_step.x = abs(step.x);\n  e_step.y = abs(step.y);\n  glBegin(GL_POINTS);\n  if (step.x == 0 && step.y == 0) //No Step\n    return;\n  point_step.x = (step.x == 0) ? 1 : step.x / e_step.x;\n  point_step.y = (step.y == 0) ? 1 : step.y / e_step.y;\n  if (step.x == 0) {   // k is endless\n    do{\n      glVertex2i(now_point.x, now_point.y);\n      now_point.y += point_step.y;\n    } while (now_point.y != end.y);\n  }\n  else if (step.y == 0) {   //k is zero\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      now_point.x += point_step.x;\n    } while (now_point.x != end.x);\n  }\n  else if (abs(step.y / step.x) == 0) {   // |k| < 1\n    Type e = -e_step.x;\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      e += 2 * e_step.y;\n      now_point.x += point_step.x;\n      if (e > 0) {\n        now_point.y += point_step.y;\n        e -= 2 * e_step.x;\n      }\n    } while (now_point.x != end.x);\n  }\n  else {    // |k| >= 1\n    Type e = -e_step.y;\n    do {\n      glVertex2i(now_point.x, now_point.y);\n      e += 2 * e_step.x;\n      now_point.y += point_step.y;\n      if (e > 0) {\n        now_point.x += point_step.x;\n        e -= 2 * e_step.y;\n      }\n    } while (now_point.y != end.y);\n  }\n  glEnd();\n  glFlush();\n\n```\n","slug":"bresenham","published":1,"updated":"2020-04-10T14:52:38.483Z","_id":"ck8ub7nbw0002qg9iddcy1zfj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在实验课上用自己的算法画直线被 diss 效率低<br>花了半天时间看了下 Bresenham 算法真 🐮🍺<br>总结一下其中的精妙之处<br>Bresebham 直线生成算法的基本原理是，每次在最大位移方向上走一步，而另一个方向是走步还是不走步取决于误差项的判别。<br>声明 k 为斜率<br>在 0≤k&lt;1 的情况下，假设当前点是 P($x_1$,$y_1$)，则下一个点在 $P_u$($x_1$+1,$y_1$+1)与 $P_d$($x_1$+1,$y_1$)中选一。<br>以 M 表示 $P_u$ 与 $P_d$ 的中点，即 M($x_1$+1,$y_1$+0.5)。设 Q 是理想直线与 x=$x_i$+1 的交点；<br>显然，若 M 在 Q 的下方，则 Pu($x_1$+1,$y_1$+1)离直线较近，应取为下一个像素；否则应取 $P_d$($x_1$+1,$y_1$)。<br>理解并不难 主要在于实现<br>依据该算法的原理基本能够实现<br>窝先试着自己写了一会<br>如果要实现各个方向的二维直线绘制<br>需要考虑多种情况 写出来很不美观<br>教材上给出了更好的解决方案：<br>同样以 0≤k&lt;1 为例<br>每次选取下个点时理想直线的 y 坐标都步进 k 个单位长度<br>累加值即为误差项 $d_i$<br>当 $d_i$ 大于 0.5 时选取 Pu 否则选取 $P_d$ 并使 $d_i$-1<br>令 $e_i$=$d_i$-0.5<br>则 $e_i$&gt;0 时选取 Pu 否则选取 $P_d$<br>经过改进，算法的效率大幅提升<br>但其中在计算斜率与误差项时会用到小数和除法<br>并且下一步的选择只与误差项的符号有关<br>因此可以进一步改进：<br>可知 $e_i$ 的值由三种值组成：$e_i$=-1/2(初始值)+(n 个)y/x(步进值)-(m 个)1(调整值)…<br>同乘 2x 即得 2x<em>$e_i$=-x+(n 个)2</em>y-(m 个)2*x….<br>这样即可得到仅由整数构成的算法<br>以上仅为对 0≤k&lt;1 情况下的讨论<br>其余的情况类似<br>附一段杂乱无章的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">point&lt;Type&gt; now_point &#x3D; start;</span><br><span class=\"line\">  point&lt;Type&gt; e_step, point_step;</span><br><span class=\"line\">  e_step.x &#x3D; abs(step.x);</span><br><span class=\"line\">  e_step.y &#x3D; abs(step.y);</span><br><span class=\"line\">  glBegin(GL_POINTS);</span><br><span class=\"line\">  if (step.x &#x3D;&#x3D; 0 &amp;&amp; step.y &#x3D;&#x3D; 0) &#x2F;&#x2F;No Step</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  point_step.x &#x3D; (step.x &#x3D;&#x3D; 0) ? 1 : step.x &#x2F; e_step.x;</span><br><span class=\"line\">  point_step.y &#x3D; (step.y &#x3D;&#x3D; 0) ? 1 : step.y &#x2F; e_step.y;</span><br><span class=\"line\">  if (step.x &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F; k is endless</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">    &#125; while (now_point.y !&#x3D; end.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if (step.y &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;k is zero</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">    &#125; while (now_point.x !&#x3D; end.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if (abs(step.y &#x2F; step.x) &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F; |k| &lt; 1</span><br><span class=\"line\">    Type e &#x3D; -e_step.x;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      e +&#x3D; 2 * e_step.y;</span><br><span class=\"line\">      now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">      if (e &gt; 0) &#123;</span><br><span class=\"line\">        now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">        e -&#x3D; 2 * e_step.x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; while (now_point.x !&#x3D; end.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;    &#x2F;&#x2F; |k| &gt;&#x3D; 1</span><br><span class=\"line\">    Type e &#x3D; -e_step.y;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      e +&#x3D; 2 * e_step.x;</span><br><span class=\"line\">      now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">      if (e &gt; 0) &#123;</span><br><span class=\"line\">        now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">        e -&#x3D; 2 * e_step.y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; while (now_point.y !&#x3D; end.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  glEnd();</span><br><span class=\"line\">  glFlush();</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在实验课上用自己的算法画直线被 diss 效率低<br>花了半天时间看了下 Bresenham 算法真 🐮🍺<br>总结一下其中的精妙之处<br>Bresebham 直线生成算法的基本原理是，每次在最大位移方向上走一步，而另一个方向是走步还是不走步取决于误差项的判别。<br>声明 k 为斜率<br>在 0≤k&lt;1 的情况下，假设当前点是 P($x_1$,$y_1$)，则下一个点在 $P_u$($x_1$+1,$y_1$+1)与 $P_d$($x_1$+1,$y_1$)中选一。<br>以 M 表示 $P_u$ 与 $P_d$ 的中点，即 M($x_1$+1,$y_1$+0.5)。设 Q 是理想直线与 x=$x_i$+1 的交点；<br>显然，若 M 在 Q 的下方，则 Pu($x_1$+1,$y_1$+1)离直线较近，应取为下一个像素；否则应取 $P_d$($x_1$+1,$y_1$)。<br>理解并不难 主要在于实现<br>依据该算法的原理基本能够实现<br>窝先试着自己写了一会<br>如果要实现各个方向的二维直线绘制<br>需要考虑多种情况 写出来很不美观<br>教材上给出了更好的解决方案：<br>同样以 0≤k&lt;1 为例<br>每次选取下个点时理想直线的 y 坐标都步进 k 个单位长度<br>累加值即为误差项 $d_i$<br>当 $d_i$ 大于 0.5 时选取 Pu 否则选取 $P_d$ 并使 $d_i$-1<br>令 $e_i$=$d_i$-0.5<br>则 $e_i$&gt;0 时选取 Pu 否则选取 $P_d$<br>经过改进，算法的效率大幅提升<br>但其中在计算斜率与误差项时会用到小数和除法<br>并且下一步的选择只与误差项的符号有关<br>因此可以进一步改进：<br>可知 $e_i$ 的值由三种值组成：$e_i$=-1/2(初始值)+(n 个)y/x(步进值)-(m 个)1(调整值)…<br>同乘 2x 即得 2x<em>$e_i$=-x+(n 个)2</em>y-(m 个)2*x….<br>这样即可得到仅由整数构成的算法<br>以上仅为对 0≤k&lt;1 情况下的讨论<br>其余的情况类似<br>附一段杂乱无章的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">point&lt;Type&gt; now_point &#x3D; start;</span><br><span class=\"line\">  point&lt;Type&gt; e_step, point_step;</span><br><span class=\"line\">  e_step.x &#x3D; abs(step.x);</span><br><span class=\"line\">  e_step.y &#x3D; abs(step.y);</span><br><span class=\"line\">  glBegin(GL_POINTS);</span><br><span class=\"line\">  if (step.x &#x3D;&#x3D; 0 &amp;&amp; step.y &#x3D;&#x3D; 0) &#x2F;&#x2F;No Step</span><br><span class=\"line\">    return;</span><br><span class=\"line\">  point_step.x &#x3D; (step.x &#x3D;&#x3D; 0) ? 1 : step.x &#x2F; e_step.x;</span><br><span class=\"line\">  point_step.y &#x3D; (step.y &#x3D;&#x3D; 0) ? 1 : step.y &#x2F; e_step.y;</span><br><span class=\"line\">  if (step.x &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F; k is endless</span><br><span class=\"line\">    do&#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">    &#125; while (now_point.y !&#x3D; end.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if (step.y &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F;k is zero</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">    &#125; while (now_point.x !&#x3D; end.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else if (abs(step.y &#x2F; step.x) &#x3D;&#x3D; 0) &#123;   &#x2F;&#x2F; |k| &lt; 1</span><br><span class=\"line\">    Type e &#x3D; -e_step.x;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      e +&#x3D; 2 * e_step.y;</span><br><span class=\"line\">      now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">      if (e &gt; 0) &#123;</span><br><span class=\"line\">        now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">        e -&#x3D; 2 * e_step.x;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; while (now_point.x !&#x3D; end.x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  else &#123;    &#x2F;&#x2F; |k| &gt;&#x3D; 1</span><br><span class=\"line\">    Type e &#x3D; -e_step.y;</span><br><span class=\"line\">    do &#123;</span><br><span class=\"line\">      glVertex2i(now_point.x, now_point.y);</span><br><span class=\"line\">      e +&#x3D; 2 * e_step.x;</span><br><span class=\"line\">      now_point.y +&#x3D; point_step.y;</span><br><span class=\"line\">      if (e &gt; 0) &#123;</span><br><span class=\"line\">        now_point.x +&#x3D; point_step.x;</span><br><span class=\"line\">        e -&#x3D; 2 * e_step.y;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; while (now_point.y !&#x3D; end.y);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  glEnd();</span><br><span class=\"line\">  glFlush();</span><br></pre></td></tr></table></figure>\n"},{"title":"c++ erase的注意事项","date":"2019-07-12T13:23:43.000Z","_content":"\n先看一段正常的代码\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\n    string str = \"123456789\";\n    str.erase(str.begin() + 2, str.end() - 2);\n    cout << str;\n\n    return 0;\n\n}\n```\n\n移除中间的一段字符  \n很好的发挥了作用  \n然后改了一下 希望依次删除字符串中的元素\n\n```\nstring::iterator it;\n    // 错误写法\n    for (it = str.begin(); it != str.end(); it++)\n    {\n        cout << *it << \" str: \" << str << endl;\n        str.erase(it);\n    }\n```\n\n![错误结果](/images/c++_erase/1.png)\n\n结果出错并且返回异常  \n查资料得知 erase 的返回值为被删除迭代器的下一个迭代器  \n修改程序\n\n```\n// 正确写法\n    for (it = str.begin(); it != str.end(); )   // 注意这里去掉了it++\n    {\n        cout << *it << \" str: \" << str << endl;\n        it = str.erase(it);\n\n    }\n```\n\n![正确结果](/images/c++_erase/2.png)\n\n结果无异常\n","source":"_posts/c++_erase.md","raw":"---\ntitle: c++ erase的注意事项\ndate: 2019-07-12 21:23:43\ntags:\n  - c++\n  - string\n---\n\n先看一段正常的代码\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n\n    string str = \"123456789\";\n    str.erase(str.begin() + 2, str.end() - 2);\n    cout << str;\n\n    return 0;\n\n}\n```\n\n移除中间的一段字符  \n很好的发挥了作用  \n然后改了一下 希望依次删除字符串中的元素\n\n```\nstring::iterator it;\n    // 错误写法\n    for (it = str.begin(); it != str.end(); it++)\n    {\n        cout << *it << \" str: \" << str << endl;\n        str.erase(it);\n    }\n```\n\n![错误结果](/images/c++_erase/1.png)\n\n结果出错并且返回异常  \n查资料得知 erase 的返回值为被删除迭代器的下一个迭代器  \n修改程序\n\n```\n// 正确写法\n    for (it = str.begin(); it != str.end(); )   // 注意这里去掉了it++\n    {\n        cout << *it << \" str: \" << str << endl;\n        it = str.erase(it);\n\n    }\n```\n\n![正确结果](/images/c++_erase/2.png)\n\n结果无异常\n","slug":"c++_erase","published":1,"updated":"2020-04-10T14:52:38.511Z","_id":"ck8ub7nch0005qg9id2cqgt1s","comments":1,"layout":"post","photos":[],"link":"","content":"<p>先看一段正常的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    string str &#x3D; &quot;123456789&quot;;</span><br><span class=\"line\">    str.erase(str.begin() + 2, str.end() - 2);</span><br><span class=\"line\">    cout &lt;&lt; str;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除中间的一段字符<br>很好的发挥了作用<br>然后改了一下 希望依次删除字符串中的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string::iterator it;</span><br><span class=\"line\">    &#x2F;&#x2F; 错误写法</span><br><span class=\"line\">    for (it &#x3D; str.begin(); it !&#x3D; str.end(); it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; &quot; str: &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">        str.erase(it);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_erase/1.png\" alt=\"错误结果\"></p>\n<p>结果出错并且返回异常<br>查资料得知 erase 的返回值为被删除迭代器的下一个迭代器<br>修改程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正确写法</span><br><span class=\"line\">    for (it &#x3D; str.begin(); it !&#x3D; str.end(); )   &#x2F;&#x2F; 注意这里去掉了it++</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; &quot; str: &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">        it &#x3D; str.erase(it);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_erase/2.png\" alt=\"正确结果\"></p>\n<p>结果无异常</p>\n","site":{"data":{}},"excerpt":"","more":"<p>先看一段正常的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    string str &#x3D; &quot;123456789&quot;;</span><br><span class=\"line\">    str.erase(str.begin() + 2, str.end() - 2);</span><br><span class=\"line\">    cout &lt;&lt; str;</span><br><span class=\"line\"></span><br><span class=\"line\">    return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>移除中间的一段字符<br>很好的发挥了作用<br>然后改了一下 希望依次删除字符串中的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string::iterator it;</span><br><span class=\"line\">    &#x2F;&#x2F; 错误写法</span><br><span class=\"line\">    for (it &#x3D; str.begin(); it !&#x3D; str.end(); it++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; &quot; str: &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">        str.erase(it);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_erase/1.png\" alt=\"错误结果\"></p>\n<p>结果出错并且返回异常<br>查资料得知 erase 的返回值为被删除迭代器的下一个迭代器<br>修改程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正确写法</span><br><span class=\"line\">    for (it &#x3D; str.begin(); it !&#x3D; str.end(); )   &#x2F;&#x2F; 注意这里去掉了it++</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; &quot; str: &quot; &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">        it &#x3D; str.erase(it);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_erase/2.png\" alt=\"正确结果\"></p>\n<p>结果无异常</p>\n"},{"title":"c++实现split(通过getline)","date":"2019-07-12T13:51:53.000Z","_content":"\n众所周知  \nc++中 string 没有自带的 split 函数(亏你还是老大哥)  \n网上关于 split 函数的优秀写法很多  \n本人不再赘述  \n近几日翻 C++API 时发现了 getline 一个有趣的方法\n\n`istream& getline (istream& is, string& str, char delim);`\n\n第一个参数是一个输入流，第二个参数是一个对字符串的常引用，第三个参数是分割符  \n在读入时遇到分割符则停止  \n可以用这个来实现单分割符的 split 功能\n\n```\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    stringstream input(\"45,65,45231,4646,4564\");\n    string str;\n    while (getline(input, str, ',')) {\n        cout << str << endl;\n    }\n    return 0;\n}\n```\n\n![](/images/c++_split_getline/1.png)\n\n简单方便快速。\n","source":"_posts/c-split-getline.md","raw":"---\ntitle: c++实现split(通过getline)\ndate: 2019-07-12 21:51:53\ntags:\n  - c++\n  - compete\n---\n\n众所周知  \nc++中 string 没有自带的 split 函数(亏你还是老大哥)  \n网上关于 split 函数的优秀写法很多  \n本人不再赘述  \n近几日翻 C++API 时发现了 getline 一个有趣的方法\n\n`istream& getline (istream& is, string& str, char delim);`\n\n第一个参数是一个输入流，第二个参数是一个对字符串的常引用，第三个参数是分割符  \n在读入时遇到分割符则停止  \n可以用这个来实现单分割符的 split 功能\n\n```\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    stringstream input(\"45,65,45231,4646,4564\");\n    string str;\n    while (getline(input, str, ',')) {\n        cout << str << endl;\n    }\n    return 0;\n}\n```\n\n![](/images/c++_split_getline/1.png)\n\n简单方便快速。\n","slug":"c-split-getline","published":1,"updated":"2020-04-10T14:52:38.543Z","_id":"ck8ub7ndc0008qg9iegtt8nce","comments":1,"layout":"post","photos":[],"link":"","content":"<p>众所周知<br>c++中 string 没有自带的 split 函数(亏你还是老大哥)<br>网上关于 split 函数的优秀写法很多<br>本人不再赘述<br>近几日翻 C++API 时发现了 getline 一个有趣的方法</p>\n<p><code>istream&amp; getline (istream&amp; is, string&amp; str, char delim);</code></p>\n<p>第一个参数是一个输入流，第二个参数是一个对字符串的常引用，第三个参数是分割符<br>在读入时遇到分割符则停止<br>可以用这个来实现单分割符的 split 功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;sstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    stringstream input(&quot;45,65,45231,4646,4564&quot;);</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    while (getline(input, str, &#39;,&#39;)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_split_getline/1.png\" alt=\"\"></p>\n<p>简单方便快速。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>众所周知<br>c++中 string 没有自带的 split 函数(亏你还是老大哥)<br>网上关于 split 函数的优秀写法很多<br>本人不再赘述<br>近几日翻 C++API 时发现了 getline 一个有趣的方法</p>\n<p><code>istream&amp; getline (istream&amp; is, string&amp; str, char delim);</code></p>\n<p>第一个参数是一个输入流，第二个参数是一个对字符串的常引用，第三个参数是分割符<br>在读入时遇到分割符则停止<br>可以用这个来实现单分割符的 split 功能</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">#include &lt;sstream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    stringstream input(&quot;45,65,45231,4646,4564&quot;);</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    while (getline(input, str, &#39;,&#39;)) &#123;</span><br><span class=\"line\">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/images/c++_split_getline/1.png\" alt=\"\"></p>\n<p>简单方便快速。</p>\n"},{"title":"Hexo 搭建个人博客","date":"2020-04-10T08:18:29.000Z","_content":"\n- 安装 git\n  > `sudo apt install git-core`\n- 安装 nodejs, npm\n  > 建议通过[官网](https://nodejs.org/en/)安装  \n  > (如果通过 apt 安装`sudo apt install nodejs npm`有可能版本过低)  \n  > 通过`ln -s [src] [obj]`将 nodejs 和 npm 软链接到`/usr/local/bin/`下\n- 注册 github 账户并创建仓库, 添加 SSH 公匙\n  > 略\n- 安装 hexo\n  > `npm install -g hexo-cli`\n","source":"_posts/Hexo搭建个人博客.md","raw":"---\ntitle: Hexo 搭建个人博客\ndate: 2020-04-10 16:18:29\ntags:\n  - Linux\n  - Hexo\n---\n\n- 安装 git\n  > `sudo apt install git-core`\n- 安装 nodejs, npm\n  > 建议通过[官网](https://nodejs.org/en/)安装  \n  > (如果通过 apt 安装`sudo apt install nodejs npm`有可能版本过低)  \n  > 通过`ln -s [src] [obj]`将 nodejs 和 npm 软链接到`/usr/local/bin/`下\n- 注册 github 账户并创建仓库, 添加 SSH 公匙\n  > 略\n- 安装 hexo\n  > `npm install -g hexo-cli`\n","slug":"Hexo搭建个人博客","published":1,"updated":"2020-04-10T14:52:38.579Z","_id":"ck8ub7nee000bqg9ihm3m609y","comments":1,"layout":"post","photos":[],"link":"","content":"<ul>\n<li>安装 git<blockquote>\n<p><code>sudo apt install git-core</code></p>\n</blockquote>\n</li>\n<li>安装 nodejs, npm<blockquote>\n<p>建议通过<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">官网</a>安装<br>(如果通过 apt 安装<code>sudo apt install nodejs npm</code>有可能版本过低)<br>通过<code>ln -s [src] [obj]</code>将 nodejs 和 npm 软链接到<code>/usr/local/bin/</code>下</p>\n</blockquote>\n</li>\n<li>注册 github 账户并创建仓库, 添加 SSH 公匙<blockquote>\n<p>略</p>\n</blockquote>\n</li>\n<li>安装 hexo<blockquote>\n<p><code>npm install -g hexo-cli</code></p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>安装 git<blockquote>\n<p><code>sudo apt install git-core</code></p>\n</blockquote>\n</li>\n<li>安装 nodejs, npm<blockquote>\n<p>建议通过<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">官网</a>安装<br>(如果通过 apt 安装<code>sudo apt install nodejs npm</code>有可能版本过低)<br>通过<code>ln -s [src] [obj]</code>将 nodejs 和 npm 软链接到<code>/usr/local/bin/</code>下</p>\n</blockquote>\n</li>\n<li>注册 github 账户并创建仓库, 添加 SSH 公匙<blockquote>\n<p>略</p>\n</blockquote>\n</li>\n<li>安装 hexo<blockquote>\n<p><code>npm install -g hexo-cli</code></p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"九宫格输入法-字符串处理方法","date":"2019-07-12T13:35:08.000Z","_content":"\n之前做过九宫格输入法的题目  \n搜了一下网上的解法没找到高效的解法  \n写一个相对高效的解法  \n先放上原题\n\n```\n假设有九宫格输入法键盘布局如下：\n\n [ 1,.?! ] [ 2ABC ] [ 3DEF  ]\n [ 4GHI  ] [ 5JKL ] [ 6MNO  ]\n [ 7PQRS ] [ 8TUV ] [ 9WXYZ ]\n           [ 0空  ]\n注意：中括号[ ]仅为了表示键盘的分隔，不是输入字符。\n每个中括号中，位于首位的数字字符即是键盘的按键，按一下即可输入该数字字符。\n多次按同一个键，则输入的字符依次循环轮流，例如按两次3，则输入D；\n按5次7，则输入S；按6次2，则输入A。按键0的输入组合是0和空格字符，即按两次0输入空格。\n\n你需要对于给定的按键组合，给出该组合对应的文本。\n\n输入格式:\n输入在一行中给出数个字符的按键组合（例如 999 表示按3次9），\n每个字符的按键组合之间用空格间隔，最后一个输入法组合之后以换行结束。\n输入数据至少包括一个字符的按键组合，且输入总长度不超过500个字符。\n\n输出格式:\n在一行中输出该按键组合对应的文本。\n\n输入样例:\n22 5555 22 666 00 88 888 7777 4444 666 44\n输出样例:\n\nALAN TURING　\n```\n\n首先直接以数字读入肯定会爆 题中给出了总长度不超过 500  \n一种很直接的思路是每次读一个字符，遇到空格做一个统计，然后根据统计的个数输出结果。  \n但既然每组输入都是相同的数字，那用字符串处理起来可能会更方便  \n这里放上我的算法\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nconst string keys[10] = {\n    \"0 \",\n    \"1,.?!\",\"2ABC\",\"3DEF\",\n    \"4GHI\",\"5JKL\",\"6MNO\",\n    \"7PQRS\",\"8TUV\",\"9WXYZ\",\n};\n\nint main() {\n    string str;\n    while (cin >> str) {        // 从流中读取输入信息\n        string key = keys[str[0] - '0'];    // 按键\n        int counts = (str.size() - 1) % key.size();    // 按下次数\n        cout << key[counts];    // 输出\n    }\n    return 0;\n}\n```\n\n可以说是钻了题目的空子。\n","source":"_posts/九宫格输入法-字符串处理方法.md","raw":"---\ntitle: 九宫格输入法-字符串处理方法\ndate: 2019-07-12 21:35:08\ntags:\n  - c++\n  - compete\n---\n\n之前做过九宫格输入法的题目  \n搜了一下网上的解法没找到高效的解法  \n写一个相对高效的解法  \n先放上原题\n\n```\n假设有九宫格输入法键盘布局如下：\n\n [ 1,.?! ] [ 2ABC ] [ 3DEF  ]\n [ 4GHI  ] [ 5JKL ] [ 6MNO  ]\n [ 7PQRS ] [ 8TUV ] [ 9WXYZ ]\n           [ 0空  ]\n注意：中括号[ ]仅为了表示键盘的分隔，不是输入字符。\n每个中括号中，位于首位的数字字符即是键盘的按键，按一下即可输入该数字字符。\n多次按同一个键，则输入的字符依次循环轮流，例如按两次3，则输入D；\n按5次7，则输入S；按6次2，则输入A。按键0的输入组合是0和空格字符，即按两次0输入空格。\n\n你需要对于给定的按键组合，给出该组合对应的文本。\n\n输入格式:\n输入在一行中给出数个字符的按键组合（例如 999 表示按3次9），\n每个字符的按键组合之间用空格间隔，最后一个输入法组合之后以换行结束。\n输入数据至少包括一个字符的按键组合，且输入总长度不超过500个字符。\n\n输出格式:\n在一行中输出该按键组合对应的文本。\n\n输入样例:\n22 5555 22 666 00 88 888 7777 4444 666 44\n输出样例:\n\nALAN TURING　\n```\n\n首先直接以数字读入肯定会爆 题中给出了总长度不超过 500  \n一种很直接的思路是每次读一个字符，遇到空格做一个统计，然后根据统计的个数输出结果。  \n但既然每组输入都是相同的数字，那用字符串处理起来可能会更方便  \n这里放上我的算法\n\n```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nconst string keys[10] = {\n    \"0 \",\n    \"1,.?!\",\"2ABC\",\"3DEF\",\n    \"4GHI\",\"5JKL\",\"6MNO\",\n    \"7PQRS\",\"8TUV\",\"9WXYZ\",\n};\n\nint main() {\n    string str;\n    while (cin >> str) {        // 从流中读取输入信息\n        string key = keys[str[0] - '0'];    // 按键\n        int counts = (str.size() - 1) % key.size();    // 按下次数\n        cout << key[counts];    // 输出\n    }\n    return 0;\n}\n```\n\n可以说是钻了题目的空子。\n","slug":"九宫格输入法-字符串处理方法","published":1,"updated":"2020-04-10T14:52:38.611Z","_id":"ck8ub7nf7000eqg9iaygs0en4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前做过九宫格输入法的题目<br>搜了一下网上的解法没找到高效的解法<br>写一个相对高效的解法<br>先放上原题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有九宫格输入法键盘布局如下：</span><br><span class=\"line\"></span><br><span class=\"line\"> [ 1,.?! ] [ 2ABC ] [ 3DEF  ]</span><br><span class=\"line\"> [ 4GHI  ] [ 5JKL ] [ 6MNO  ]</span><br><span class=\"line\"> [ 7PQRS ] [ 8TUV ] [ 9WXYZ ]</span><br><span class=\"line\">           [ 0空  ]</span><br><span class=\"line\">注意：中括号[ ]仅为了表示键盘的分隔，不是输入字符。</span><br><span class=\"line\">每个中括号中，位于首位的数字字符即是键盘的按键，按一下即可输入该数字字符。</span><br><span class=\"line\">多次按同一个键，则输入的字符依次循环轮流，例如按两次3，则输入D；</span><br><span class=\"line\">按5次7，则输入S；按6次2，则输入A。按键0的输入组合是0和空格字符，即按两次0输入空格。</span><br><span class=\"line\"></span><br><span class=\"line\">你需要对于给定的按键组合，给出该组合对应的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">输入格式:</span><br><span class=\"line\">输入在一行中给出数个字符的按键组合（例如 999 表示按3次9），</span><br><span class=\"line\">每个字符的按键组合之间用空格间隔，最后一个输入法组合之后以换行结束。</span><br><span class=\"line\">输入数据至少包括一个字符的按键组合，且输入总长度不超过500个字符。</span><br><span class=\"line\"></span><br><span class=\"line\">输出格式:</span><br><span class=\"line\">在一行中输出该按键组合对应的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">输入样例:</span><br><span class=\"line\">22 5555 22 666 00 88 888 7777 4444 666 44</span><br><span class=\"line\">输出样例:</span><br><span class=\"line\"></span><br><span class=\"line\">ALAN TURING</span><br></pre></td></tr></table></figure>\n\n<p>首先直接以数字读入肯定会爆 题中给出了总长度不超过 500<br>一种很直接的思路是每次读一个字符，遇到空格做一个统计，然后根据统计的个数输出结果。<br>但既然每组输入都是相同的数字，那用字符串处理起来可能会更方便<br>这里放上我的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const string keys[10] &#x3D; &#123;</span><br><span class=\"line\">    &quot;0 &quot;,</span><br><span class=\"line\">    &quot;1,.?!&quot;,&quot;2ABC&quot;,&quot;3DEF&quot;,</span><br><span class=\"line\">    &quot;4GHI&quot;,&quot;5JKL&quot;,&quot;6MNO&quot;,</span><br><span class=\"line\">    &quot;7PQRS&quot;,&quot;8TUV&quot;,&quot;9WXYZ&quot;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    while (cin &gt;&gt; str) &#123;        &#x2F;&#x2F; 从流中读取输入信息</span><br><span class=\"line\">        string key &#x3D; keys[str[0] - &#39;0&#39;];    &#x2F;&#x2F; 按键</span><br><span class=\"line\">        int counts &#x3D; (str.size() - 1) % key.size();    &#x2F;&#x2F; 按下次数</span><br><span class=\"line\">        cout &lt;&lt; key[counts];    &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以说是钻了题目的空子。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前做过九宫格输入法的题目<br>搜了一下网上的解法没找到高效的解法<br>写一个相对高效的解法<br>先放上原题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设有九宫格输入法键盘布局如下：</span><br><span class=\"line\"></span><br><span class=\"line\"> [ 1,.?! ] [ 2ABC ] [ 3DEF  ]</span><br><span class=\"line\"> [ 4GHI  ] [ 5JKL ] [ 6MNO  ]</span><br><span class=\"line\"> [ 7PQRS ] [ 8TUV ] [ 9WXYZ ]</span><br><span class=\"line\">           [ 0空  ]</span><br><span class=\"line\">注意：中括号[ ]仅为了表示键盘的分隔，不是输入字符。</span><br><span class=\"line\">每个中括号中，位于首位的数字字符即是键盘的按键，按一下即可输入该数字字符。</span><br><span class=\"line\">多次按同一个键，则输入的字符依次循环轮流，例如按两次3，则输入D；</span><br><span class=\"line\">按5次7，则输入S；按6次2，则输入A。按键0的输入组合是0和空格字符，即按两次0输入空格。</span><br><span class=\"line\"></span><br><span class=\"line\">你需要对于给定的按键组合，给出该组合对应的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">输入格式:</span><br><span class=\"line\">输入在一行中给出数个字符的按键组合（例如 999 表示按3次9），</span><br><span class=\"line\">每个字符的按键组合之间用空格间隔，最后一个输入法组合之后以换行结束。</span><br><span class=\"line\">输入数据至少包括一个字符的按键组合，且输入总长度不超过500个字符。</span><br><span class=\"line\"></span><br><span class=\"line\">输出格式:</span><br><span class=\"line\">在一行中输出该按键组合对应的文本。</span><br><span class=\"line\"></span><br><span class=\"line\">输入样例:</span><br><span class=\"line\">22 5555 22 666 00 88 888 7777 4444 666 44</span><br><span class=\"line\">输出样例:</span><br><span class=\"line\"></span><br><span class=\"line\">ALAN TURING</span><br></pre></td></tr></table></figure>\n\n<p>首先直接以数字读入肯定会爆 题中给出了总长度不超过 500<br>一种很直接的思路是每次读一个字符，遇到空格做一个统计，然后根据统计的个数输出结果。<br>但既然每组输入都是相同的数字，那用字符串处理起来可能会更方便<br>这里放上我的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">const string keys[10] &#x3D; &#123;</span><br><span class=\"line\">    &quot;0 &quot;,</span><br><span class=\"line\">    &quot;1,.?!&quot;,&quot;2ABC&quot;,&quot;3DEF&quot;,</span><br><span class=\"line\">    &quot;4GHI&quot;,&quot;5JKL&quot;,&quot;6MNO&quot;,</span><br><span class=\"line\">    &quot;7PQRS&quot;,&quot;8TUV&quot;,&quot;9WXYZ&quot;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    while (cin &gt;&gt; str) &#123;        &#x2F;&#x2F; 从流中读取输入信息</span><br><span class=\"line\">        string key &#x3D; keys[str[0] - &#39;0&#39;];    &#x2F;&#x2F; 按键</span><br><span class=\"line\">        int counts &#x3D; (str.size() - 1) % key.size();    &#x2F;&#x2F; 按下次数</span><br><span class=\"line\">        cout &lt;&lt; key[counts];    &#x2F;&#x2F; 输出</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以说是钻了题目的空子。</p>\n"},{"title":"反转字符串(杂谈)","date":"2019-07-12T13:40:21.000Z","_content":"\n反转字符串是个很简单也比较常用的方法  \n此文仅做杂谈，无技术含量\n\n```\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid myReverse(const string& str) {\n    char* c_str = (char*)str.c_str();\n    char* p, * q;\n    p = c_str;\n    q = c_str + str.size() - 1;\n    while (p < q) {\n        char temp_c = *p;\n        *p = *q;\n        *q = temp_c;\n        p++;\n        q--;\n    }\n}\n\nint main() {\n    string str = \"123456789\";\n    myReverse(str);    // 反转方式1\n    cout << str << endl;\n    reverse(str.begin() + 2, str.end() - 2);    // 反转方式2\n    cout << str << endl;\n    cout << string(str.rbegin(), str.rend());    // 反转方式3\n    return 0;\n}\n```\n\n运用迭代器还有更多有趣的写法  \n这里不一一列出\n","source":"_posts/反转字符串.md","raw":"---\ntitle: 反转字符串(杂谈)\ndate: 2019-07-12 21:40:21\ntags:\n  - c++\n  - compete\n---\n\n反转字符串是个很简单也比较常用的方法  \n此文仅做杂谈，无技术含量\n\n```\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nvoid myReverse(const string& str) {\n    char* c_str = (char*)str.c_str();\n    char* p, * q;\n    p = c_str;\n    q = c_str + str.size() - 1;\n    while (p < q) {\n        char temp_c = *p;\n        *p = *q;\n        *q = temp_c;\n        p++;\n        q--;\n    }\n}\n\nint main() {\n    string str = \"123456789\";\n    myReverse(str);    // 反转方式1\n    cout << str << endl;\n    reverse(str.begin() + 2, str.end() - 2);    // 反转方式2\n    cout << str << endl;\n    cout << string(str.rbegin(), str.rend());    // 反转方式3\n    return 0;\n}\n```\n\n运用迭代器还有更多有趣的写法  \n这里不一一列出\n","slug":"反转字符串","published":1,"updated":"2020-04-10T14:52:38.643Z","_id":"ck8ub7ng9000hqg9i889r6d79","comments":1,"layout":"post","photos":[],"link":"","content":"<p>反转字符串是个很简单也比较常用的方法<br>此文仅做杂谈，无技术含量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void myReverse(const string&amp; str) &#123;</span><br><span class=\"line\">    char* c_str &#x3D; (char*)str.c_str();</span><br><span class=\"line\">    char* p, * q;</span><br><span class=\"line\">    p &#x3D; c_str;</span><br><span class=\"line\">    q &#x3D; c_str + str.size() - 1;</span><br><span class=\"line\">    while (p &lt; q) &#123;</span><br><span class=\"line\">        char temp_c &#x3D; *p;</span><br><span class=\"line\">        *p &#x3D; *q;</span><br><span class=\"line\">        *q &#x3D; temp_c;</span><br><span class=\"line\">        p++;</span><br><span class=\"line\">        q--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string str &#x3D; &quot;123456789&quot;;</span><br><span class=\"line\">    myReverse(str);    &#x2F;&#x2F; 反转方式1</span><br><span class=\"line\">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    reverse(str.begin() + 2, str.end() - 2);    &#x2F;&#x2F; 反转方式2</span><br><span class=\"line\">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; string(str.rbegin(), str.rend());    &#x2F;&#x2F; 反转方式3</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运用迭代器还有更多有趣的写法<br>这里不一一列出</p>\n","site":{"data":{}},"excerpt":"","more":"<p>反转字符串是个很简单也比较常用的方法<br>此文仅做杂谈，无技术含量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;algorithm&gt;</span><br><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void myReverse(const string&amp; str) &#123;</span><br><span class=\"line\">    char* c_str &#x3D; (char*)str.c_str();</span><br><span class=\"line\">    char* p, * q;</span><br><span class=\"line\">    p &#x3D; c_str;</span><br><span class=\"line\">    q &#x3D; c_str + str.size() - 1;</span><br><span class=\"line\">    while (p &lt; q) &#123;</span><br><span class=\"line\">        char temp_c &#x3D; *p;</span><br><span class=\"line\">        *p &#x3D; *q;</span><br><span class=\"line\">        *q &#x3D; temp_c;</span><br><span class=\"line\">        p++;</span><br><span class=\"line\">        q--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    string str &#x3D; &quot;123456789&quot;;</span><br><span class=\"line\">    myReverse(str);    &#x2F;&#x2F; 反转方式1</span><br><span class=\"line\">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    reverse(str.begin() + 2, str.end() - 2);    &#x2F;&#x2F; 反转方式2</span><br><span class=\"line\">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; string(str.rbegin(), str.rend());    &#x2F;&#x2F; 反转方式3</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运用迭代器还有更多有趣的写法<br>这里不一一列出</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck8ub7nbw0002qg9iddcy1zfj","tag_id":"ck8ub6lcy0006ff9i7rlr4wui","_id":"ck8ub7nc20003qg9if2o233r5"},{"post_id":"ck8ub7nbw0002qg9iddcy1zfj","tag_id":"ck8ub6lcz0007ff9i6gp16ab8","_id":"ck8ub7nc30004qg9id5bv08an"},{"post_id":"ck8ub7nch0005qg9id2cqgt1s","tag_id":"ck8ub6lcy0006ff9i7rlr4wui","_id":"ck8ub7ncv0006qg9i2ay9hwgh"},{"post_id":"ck8ub7nch0005qg9id2cqgt1s","tag_id":"ck8ub6ld2000bff9i0uf02qm7","_id":"ck8ub7ncw0007qg9id8xhfqlg"},{"post_id":"ck8ub7ndc0008qg9iegtt8nce","tag_id":"ck8ub6lcy0006ff9i7rlr4wui","_id":"ck8ub7ndj0009qg9igihdh3ks"},{"post_id":"ck8ub7ndc0008qg9iegtt8nce","tag_id":"ck8ub6lda000gff9igebsbh62","_id":"ck8ub7ndj000aqg9ifdfigiiw"},{"post_id":"ck8ub7nee000bqg9ihm3m609y","tag_id":"ck8ub6lcn0000ff9i2jie6fxb","_id":"ck8ub7nem000cqg9i8u6m5j5r"},{"post_id":"ck8ub7nee000bqg9ihm3m609y","tag_id":"ck8ub6lco0001ff9i1k9dg2wp","_id":"ck8ub7nem000dqg9icnjc7uzr"},{"post_id":"ck8ub7nf7000eqg9iaygs0en4","tag_id":"ck8ub6lcy0006ff9i7rlr4wui","_id":"ck8ub7nfg000fqg9icqp0hwf3"},{"post_id":"ck8ub7nf7000eqg9iaygs0en4","tag_id":"ck8ub6lda000gff9igebsbh62","_id":"ck8ub7nfg000gqg9i1xnu72fp"},{"post_id":"ck8ub7ng9000hqg9i889r6d79","tag_id":"ck8ub6lcy0006ff9i7rlr4wui","_id":"ck8ub7nga000iqg9i37j556hn"},{"post_id":"ck8ub7ng9000hqg9i889r6d79","tag_id":"ck8ub6lda000gff9igebsbh62","_id":"ck8ub7ngb000jqg9ie5rx6vch"}],"Tag":[{"name":"Linux Hexo","_id":"ck8u006lv0000339i06dsbz7u"},{"name":"Linux","_id":"ck8ub6lcn0000ff9i2jie6fxb"},{"name":"Hexo","_id":"ck8ub6lco0001ff9i1k9dg2wp"},{"name":"c++","_id":"ck8ub6lcy0006ff9i7rlr4wui"},{"name":"Computer Graphics","_id":"ck8ub6lcz0007ff9i6gp16ab8"},{"name":"string","_id":"ck8ub6ld2000bff9i0uf02qm7"},{"name":"compete","_id":"ck8ub6lda000gff9igebsbh62"}]}}